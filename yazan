<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI Gun Game</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            background-color: #87CEEB;
        }

        
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="scoreOverlay"></div>

    <script>
        // Three.js 3D Gun Game - Fortnite Style

        let scene, camera, renderer;
        let player1, player2;
        let enemies = [];
        let bullets = [];
        let weaponPickups = [];
        let scores = { player1: 0, player2: 0 };
        let health = { player1: 100, player2: 100 };
        let gameRunning = true;

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        class Game {
            constructor() {
                this.init();
                this.animate();
            }

            init() {
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue like Fortnite
                scene.fog = new THREE.Fog(0x87CEEB, 200, 500);

                // Camera setup - Third person view
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 20, 40);
                camera.lookAt(0, 5, 0);

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFShadowShadowMap;
                document.body.appendChild(renderer.domElement);

                // Lighting - Fortnite style bright lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(100, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.far = 500;
                scene.add(directionalLight);

                // Ground - Larger map
                const groundGeometry = new THREE.PlaneGeometry(300, 300);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);

                // Add some buildings/obstacles for cover
                this.createObstacles();

                // Create players
                player1 = new Player(-50, 0, 0x00FF00, 'Player 1');
                player2 = new Player(50, 0, 0xFF0000, 'Player 2');

                // Spawn enemies and weapons
                this.spawnEnemies();
                this.spawnWeaponPickup();
                setInterval(() => this.spawnEnemies(), 3000);
                setInterval(() => this.spawnWeaponPickup(), 5000);

                // Update displays
                this.updateHUD();

                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            createObstacles() {
                const positions = [
                    { x: 30, z: 30 }, { x: -30, z: -30 }, { x: 50, z: -50 },
                    { x: -50, z: 50 }, { x: 0, z: 60 }, { x: 0, z: -60 }
                ];

                positions.forEach(pos => {
                    const geometry = new THREE.BoxGeometry(15, 20, 15);
                    const material = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const building = new THREE.Mesh(geometry, material);
                    building.position.set(pos.x, 10, pos.z);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    scene.add(building);
                });
            }

            spawnEnemies() {
                if (!gameRunning) return;
                const x = (Math.random() - 0.5) * 250;
                const z = (Math.random() - 0.5) * 250;
                if (Math.abs(x) < 80 && Math.abs(z) < 80) return; // Don't spawn near players
                enemies.push(new Enemy(x, z));
            }

            spawnWeaponPickup() {
                if (!gameRunning) return;
                const x = (Math.random() - 0.5) * 250;
                const z = (Math.random() - 0.5) * 250;
                if (Math.abs(x) < 80 && Math.abs(z) < 80) return;
                weaponPickups.push(new WeaponPickup(x, z));
            }

            updateHUD() {
                const overlay = document.getElementById('scoreOverlay');
                if (overlay) {
                    overlay.innerHTML = `
                        <div style="position: fixed; top: 20px; left: 20px; color: #00FF00; font-size: 20px; font-weight: bold; z-index: 100;">
                            <div>Player 1: ${scores.player1} Kills</div>
                            <div>Health: ${health.player1}/100</div>
                        </div>
                        <div style="position: fixed; top: 20px; right: 20px; color: #FF0000; font-size: 20px; font-weight: bold; text-align: right; z-index: 100;">
                            <div>Bot (P2): ${scores.player2} Kills</div>
                            <div>Health: ${health.player2}/100</div>
                        </div>
                        <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: #FFFFFF; text-align: center; z-index: 100; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;">
                            <p><strong>Player 1:</strong> W/S to Move Forward/Back | A/D to Turn | SPACE to shoot</p>
                            <p><strong>Player 2:</strong> is controlled by AI and will assist you!</p>
                            <p>Defeat enemies and collect weapons!</p>
                        </div>
                    `;
                }
            }

            update() {
                if (!gameRunning) return;

                // Follow players with camera
                const midX = (player1.x + player2.x) / 2;
                const midZ = (player1.z + player2.z) / 2;
                camera.position.set(midX, 40, midZ + 60);
                camera.lookAt(midX, 5, midZ);

                // Update players (passing enemies so bot can track them)
                player1.update(keys, enemies);
                player2.update(keys, enemies);

                // Check player collisions with weapons
                weaponPickups.forEach((pickup, index) => {
                    if (player1.collidesWith(pickup)) {
                        player1.upgradeWeapon();
                        scene.remove(pickup.mesh);
                        weaponPickups.splice(index, 1);
                        this.updateHUD();
                    }
                    if (player2.collidesWith(pickup)) {
                        player2.upgradeWeapon();
                        scene.remove(pickup.mesh);
                        weaponPickups.splice(index, 1);
                        this.updateHUD();
                    }
                });

                // Update bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].update();
                    if (bullets[i].isOffScreen()) {
                        scene.remove(bullets[i].mesh);
                        bullets.splice(i, 1);
                    }
                }

                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update();
                    
                    if (enemies[i].isOffScreen()) {
                        scene.remove(enemies[i].mesh);
                        enemies.splice(i, 1);
                        continue;
                    }

                    // Check collision with bullets
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        if (enemies[i].collidesWith(bullets[j])) {
                            if (bullets[j].owner === 'player1') {
                                scores.player1 += 1;
                            } else {
                                scores.player2 += 1;
                            }
                            scene.remove(enemies[i].mesh);
                            scene.remove(bullets[j].mesh);
                            enemies.splice(i, 1);
                            bullets.splice(j, 1);
                            this.updateHUD();
                            break;
                        }
                    }

                    // Enemies damage players on contact
                    if (enemies[i] && enemies[i].collidesWithPlayer(player1)) {
                        health.player1 -= 0.5;
                        if (health.player1 <= 0) {
                            gameRunning = false;
                            alert('Player 1 Eliminated! Game Over!');
                            location.reload();
                        }
                        this.updateHUD();
                    }
                    if (enemies[i] && enemies[i].collidesWithPlayer(player2)) {
                        health.player2 -= 0.5;
                        if (health.player2 <= 0) {
                            // Bot died
                            health.player2 = 0;
                            this.updateHUD();
                        }
                    }
                }
            }

            animate = () => {
                requestAnimationFrame(this.animate);
                this.update();
                renderer.render(scene, camera);
            }

            onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        class Player {
            constructor(x, z, color, name) {
                this.name = name;
                this.x = x;
                this.z = z;
                this.angle = 0; // Rotation angle
                this.speed = 0.7;
                this.color = color;
                this.weaponLevel = 1;
                this.shootCooldown = 0;
                
                // Create mesh - Player body
                const geometry = new THREE.BoxGeometry(2, 3, 2);
                const material = new THREE.MeshPhongMaterial({ color: color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, 1.5, z);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.7, 32, 32);
                this.head = new THREE.Mesh(headGeometry, material);
                this.head.position.y = 2.2;
                this.head.castShadow = true;
                this.mesh.add(this.head);

                // Gun barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
                const barrelMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                this.barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                // Position barrel forward relative to mesh
                this.barrel.position.set(0, 1.5, 2);
                this.barrel.rotation.x = Math.PI / 2;
                this.barrel.castShadow = true;
                this.mesh.add(this.barrel);
            }

            update(keys, enemies) {
                if (health[this.name === 'Player 1' ? 'player1' : 'player2'] <= 0) {
                    this.mesh.visible = false;
                    return; // Don't update if dead
                }

                if (this.name === 'Player 1') {
                    // Turning controls
                    if (keys['a'] || keys['A']) this.angle += 0.05;
                    if (keys['d'] || keys['D']) this.angle -= 0.05;

                    // Forward / Backward along the angle
                    if (keys['w'] || keys['W']) {
                        this.x += Math.sin(this.angle) * this.speed;
                        this.z += Math.cos(this.angle) * this.speed;
                    }
                    if (keys['s'] || keys['S']) {
                        this.x -= Math.sin(this.angle) * this.speed;
                        this.z -= Math.cos(this.angle) * this.speed;
                    }

                    if (keys[' '] && this.shootCooldown <= 0) {
                        this.shoot('player1');
                        this.shootCooldown = 10 - (this.weaponLevel * 2);
                    }
                } else {
                    // Player 2 AI
                    this.runAI(enemies);
                }

                this.shootCooldown--;

                // Clamp position to map
                this.x = Math.max(-130, Math.min(130, this.x));
                this.z = Math.max(-130, Math.min(130, this.z));

                this.mesh.position.set(this.x, 1.5, this.z);
                this.mesh.rotation.y = this.angle; // Apply rotation to mesh
            }

            runAI(enemies) {
                if (enemies.length === 0) return;

                let nearestEnemy = null;
                let minDist = Infinity;

                // Find closest enemy
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dz = enemy.z - this.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestEnemy = enemy;
                    }
                });

                if (nearestEnemy) {
                    // Aim at the enemy
                    this.angle = Math.atan2(nearestEnemy.x - this.x, nearestEnemy.z - this.z);

                    // Move towards enemy if they are far away
                    if (minDist > 25) {
                        this.x += Math.sin(this.angle) * (this.speed * 0.75); // AI moves slightly slower
                        this.z += Math.cos(this.angle) * (this.speed * 0.75);
                    }

                    // Shoot if facing them and close enough
                    if (this.shootCooldown <= 0 && minDist < 80) {
                        this.shoot('player2');
                        this.shootCooldown = 25 - (this.weaponLevel * 2); // AI shoots slightly slower
                    }
                }
            }

            shoot(owner) {
                // Spawn bullet right at the tip of the gun barrel based on angle
                const spawnDist = 3;
                const bulletX = this.x + Math.sin(this.angle) * spawnDist;
                const bulletZ = this.z + Math.cos(this.angle) * spawnDist;
                
                bullets.push(new Bullet(bulletX, bulletZ, owner, this.weaponLevel, this.angle));
            }

            upgradeWeapon() {
                this.weaponLevel = Math.min(5, this.weaponLevel + 1);
                this.barrel.scale.set(1, 1 + this.weaponLevel * 0.2, 1);
            }

            collidesWith(pickup) {
                const dx = this.x - pickup.x;
                const dz = this.z - pickup.z;
                return Math.sqrt(dx * dx + dz * dz) < 3;
            }
        }

        class Bullet {
            constructor(x, z, owner, power, angle) {
                this.x = x;
                this.z = z;
                this.speed = 2 + power * 0.5;
                this.owner = owner;
                this.power = power;

                // Calculate velocity based on rotation angle
                this.vx = Math.sin(angle) * this.speed;
                this.vz = Math.cos(angle) * this.speed;

                const geometry = new THREE.SphereGeometry(0.3, 8, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0xFFFF00 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, 1.5, z);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
            }

            update() {
                // Move along angle trajectory
                this.x += this.vx;
                this.z += this.vz;
                this.mesh.position.set(this.x, 1.5, this.z);
            }

            isOffScreen() {
                return Math.abs(this.z) > 200 || Math.abs(this.x) > 200;
            }
        }

        class Enemy {
            constructor(x, z) {
                this.x = x;
                this.z = z;
                this.speed = 0.4;
                this.radius = 1.5;

                const geometry = new THREE.IcosahedronGeometry(1.5, 4);
                const material = new THREE.MeshPhongMaterial({ color: 0xFF6600 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, 1, z);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
            }

            update() {
                this.z += this.speed;
                this.mesh.position.z = this.z;
                this.mesh.rotation.x += 0.02;
                this.mesh.rotation.y += 0.03;
            }

            isOffScreen() {
                return Math.abs(this.z) > 200 || Math.abs(this.x) > 200;
            }

            collidesWith(bullet) {
                const dx = this.x - bullet.x;
                const dz = this.z - bullet.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                return distance < this.radius + 0.3;
            }

            collidesWithPlayer(player) {
                const dx = this.x - player.x;
                const dz = this.z - player.z;
                return Math.sqrt(dx * dx + dz * dz) < 3;
            }
        }

        class WeaponPickup {
            constructor(x, z) {
                this.x = x;
                this.z = z;

                const geometry = new THREE.BoxGeometry(1, 1, 3);
                const material = new THREE.MeshPhongMaterial({ color: 0x00FFFF, emissive: 0x00FFFF });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, 0.5, z);
                this.mesh.castShadow = true;
                scene.add(this.mesh);

                this.rotation = 0;
            }

            update() {
                this.rotation += 0.05;
                this.mesh.rotation.y = this.rotation;
                this.mesh.position.y = 0.5 + Math.sin(this.rotation) * 0.3;
            }
        }

        // Start game when page loads
        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>
